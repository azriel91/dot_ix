use leptos::{
    component,
    prelude::{
        ClassAttribute, ElementChild, Get, GlobalAttributes, GlobalOnAttributes, NodeRefAttribute,
        Signal,
    },
    view, IntoView,
};

#[cfg(not(feature = "server_side_graphviz"))]
use leptos::prelude::{Effect, NodeRef};

use dot_ix_model::{common::DotSrcAndStyles, info_graph::InfoGraph};

#[cfg(feature = "server_side_graphviz")]
use leptos::{server, server_fn::error::NoCustomError, ServerFnError, Suspense};

#[cfg(any(
    all(feature = "ssr", feature = "server_side_graphviz"),
    target_arch = "wasm32"
))]
use dot_ix_model::common::{dot_src_and_styles::GraphvizImage, Images};

#[cfg(not(feature = "server_side_graphviz"))]
use leptos::html::Div;
#[cfg(not(feature = "server_side_graphviz"))]
use leptos_meta::Script;

cfg_if::cfg_if! { if #[cfg(target_arch = "wasm32")] {
    use wasm_bindgen::{prelude::wasm_bindgen, JsValue};

    #[wasm_bindgen(module = "/public/js/graphviz_dot_svg.js")]
    extern "C" {
        #[wasm_bindgen(catch)]
        fn graphviz_dot_svg(dot_src: String, opts: &JsValue) -> Result<String, JsValue>;
    }
}}

#[cfg(not(feature = "server_side_graphviz"))]
const SVG_WRITE_TO_CLIPBOARD: &str = include_str!("dot_svg/svg_write_to_clipboard.js");

#[cfg(feature = "server_side_graphviz")]
#[server]
pub async fn dot_svg(
    info_graph: InfoGraph,
    dot_src_and_styles: DotSrcAndStyles,
) -> Result<(String, String), ServerFnError<NoCustomError>> {
    use dot_ix_model::info_graph;
    use std::process::Stdio;
    use tokio::io::{AsyncReadExt, AsyncWriteExt};

    let DotSrcAndStyles {
        dot_src,
        styles: _,
        opts: _,
        theme_warnings: _,
    } = dot_src_and_styles;

    let mut dot_process = tokio::process::Command::new("dot")
        .arg("-Tsvg")
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .spawn()
        .expect("Failed to spawn dot command");

    if let Some(mut stdin) = dot_process.stdin.take() {
        stdin
            .write_all(dot_src.as_bytes())
            .await
            .map_err(|error| ServerFnError::<NoCustomError>::ServerError(format!("{error}")))?;
    }

    let mut dot_svg = String::with_capacity(dot_src.len());
    if let Some(mut stdout) = dot_process.stdout.take() {
        stdout
            .read_to_string(&mut dot_svg)
            .await
            .map_err(|error| ServerFnError::<NoCustomError>::ServerError(format!("{error}")))?;
    }

    let mut dot_stderr = String::new();
    if let Some(mut stderr) = dot_process.stderr.take() {
        stderr
            .read_to_string(&mut dot_stderr)
            .await
            .map_err(|error| ServerFnError::<NoCustomError>::ServerError(format!("{error}")))?;
    }

    dot_process.wait().await.map_err(|error| {
        ServerFnError::<NoCustomError>::ServerError(format!("{dot_stderr}{error}"))
    })?;

    let styles = dot_svg_styles(&dot_src).await?;

    let images = info_graph.images();
    let image_defs = svg_image_defs(images);
    dot_svg = dot_svg_sanitize(&dot_svg, &styles, images, &image_defs);
    dot_svg = dot_svg_append_extra(&dot_svg, info_graph.svg_extra());

    Ok((dot_svg, dot_stderr))
}

#[cfg(any(
    all(feature = "ssr", feature = "server_side_graphviz"),
    target_arch = "wasm32"
))]
fn svg_image_defs(images: &Images) -> String {
    images
        .iter()
        .map(|(image_id, image)| {
            let GraphvizImage {
                path,
                width,
                height,
            } = image;
            format!(
                "<image \
                id=\"{image_id}\" \
                href=\"{path}\" \
                width=\"{width}\" \
                height=\"{height}\" \
                />\n"
            )
        })
        .collect::<String>()
}

/// Removes attributes from the SVG generated by dot, so that they don't
/// override tailwind styles.
///
/// # Parameters
///
/// * `dot_svg`: The SVG generated by `dot`.
/// * `styles`: The CSS styles to include within the `<style>$styles</style>`
///   element.
#[cfg(any(
    all(feature = "ssr", feature = "server_side_graphviz"),
    target_arch = "wasm32"
))]
fn dot_svg_sanitize(dot_svg: &str, styles: &str, images: &Images, images_defs: &str) -> String {
    let dot_svg = dot_svg
        .replacen("<g", &format!("<style>{styles}</style>\n<g"), 1)
        .replace("<g ", "<g tabindex=\"0\" ")
        .replace("fill=\"#000000\"", "")
        .replace("stroke=\"#000000\"", "")
        .replace("stroke=\"black\"", "")
        .replace("&nbsp;", "&#160;");

    let dot_svg = images
        .keys()
        .fold(dot_svg, |dot_svg, image_id| {
            dot_svg.replace(
                format!("<image xlink:href=\"{image_id}\"").as_str(),
                format!("<use href=\"#{image_id}\"").as_str(),
            )
        })
        .replace("</image>", "</use>")
        // Do this last, so all the previous replacements don't re-allocate the potentially large
        // string
        .replacen("<g", &format!("<defs>{images_defs}</defs>\n<g"), 1);

    dot_svg
}

/// Adds the extra SVG elements provided in the `InfoGraph`.
///
/// The `svg_extra` elements are inserted without sanitization, so malformed /
/// malicious input will be passed through.
///
/// # Parameters
///
/// * `dot_svg`: The SVG generated by `dot`.
/// * `svg_extra`: The extra SVG elements to insert.
#[cfg(any(
    all(feature = "ssr", feature = "server_side_graphviz"),
    target_arch = "wasm32"
))]
fn dot_svg_append_extra(dot_svg: &str, svg_extra: &str) -> String {
    dot_svg.replacen("<g", &format!("{svg_extra}\n<g"), 1)
}

#[cfg(feature = "ssr")]
#[cfg(feature = "server_side_graphviz")]
async fn dot_svg_styles(dot_src: &str) -> Result<String, ServerFnError<NoCustomError>> {
    use std::process::Stdio;
    use tokio::io::AsyncReadExt;

    let tempdir = tempfile::tempdir()
        .map_err(|error| ServerFnError::<NoCustomError>::ServerError(format!("{error}")))?;

    let dot_path = tempdir.path().join("dot.dot");
    let dot_write = tokio::fs::write(&dot_path, dot_src);

    let tailwind_config_path = tempdir.path().join("tailwind.config.js");
    let tailwind_config_write = tokio::fs::write(
        &tailwind_config_path,
        b"/** @type {import('tailwindcss').Config} */\nmodule.exports = { content: ['./dot.dot'] }",
    );

    let tailwind_css_path = tempdir.path().join("tailwind.css");
    let tailwind_css_write = tokio::fs::write(
        &tailwind_css_path,
        b"\n@tailwind components;\n@tailwind utilities;\n",
    );

    let ((), (), ()) = tokio::try_join!(tailwind_config_write, dot_write, tailwind_css_write,)
        .map_err(|error| ServerFnError::<NoCustomError>::ServerError(format!("{error}")))?;

    let mut tailwind_process = tokio::process::Command::new("tailwind")
        .current_dir(tempdir.path())
        .arg("-i")
        .arg(&tailwind_css_path)
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .spawn()
        .map_err(|error| ServerFnError::<NoCustomError>::ServerError(format!("{error}")))?;

    let mut svg_styles = String::with_capacity(dot_src.len());
    if let Some(mut stdout) = tailwind_process.stdout.take() {
        stdout
            .read_to_string(&mut svg_styles)
            .await
            .map_err(|error| ServerFnError::<NoCustomError>::ServerError(format!("{error}")))?;
    }

    let mut tailwind_stderr = String::new();
    if let Some(mut stderr) = tailwind_process.stderr.take() {
        stderr
            .read_to_string(&mut tailwind_stderr)
            .await
            .map_err(|error| ServerFnError::<NoCustomError>::ServerError(format!("{error}")))?;
    }

    tailwind_process.wait().await.map_err(|error| {
        ServerFnError::<NoCustomError>::ServerError(format!("{tailwind_stderr}{error}"))
    })?;

    Ok(svg_styles)
}

/// Renders a graphviz graph as an SVG.
#[cfg(feature = "server_side_graphviz")]
#[component]
pub fn DotSvg(
    info_graph: Signal<InfoGraph>,
    dot_src_and_styles: Signal<Option<DotSrcAndStyles>>,
    #[prop(default = Signal::from(false))] diagram_only: Signal<bool>,
) -> impl IntoView {
    let _diagram_only = diagram_only;
    let dot_svg_and_error_resource = leptos::create_resource(
        move || dot_src_and_styles.get(),
        move |dot_src_and_styles| async move {
            if let Some(dot_src_and_styles) = dot_src_and_styles {
                if !dot_src_and_styles.dot_src.is_empty() {
                    let info_graph = info_graph.get().clone();
                    match dot_svg(info_graph, dot_src_and_styles).await {
                        Ok((dot_svg, error_text)) => (dot_svg, error_text),
                        Err(error) => (String::new(), format!("{error}")),
                    }
                } else {
                    (String::new(), String::new())
                }
            } else {
                (String::new(), String::new())
            }
        },
    );

    view! {
        <Suspense
            fallback=move || view! { <p>"Loading..."</p> }
        >
            { move || {
                dot_svg_and_error_resource.get()
                    .map(|(dot_svg, error_text)| view! {
                        <div>
                            <div inner_html=dot_svg />

                            <div class={
                                let error_text_empty = error_text.is_empty();
                                move || {
                                    if error_text_empty {
                                        "hidden"
                                    } else {
                                        "
                                        border
                                        border-amber-300
                                        bg-gradient-to-b from-amber-100 to-amber-200
                                        rounded
                                        "
                                    }
                                }
                            }
                            >{error_text}</div>
                        </div>
                    })
            }}
        </Suspense>
    }
}

/// Renders a graphviz graph as an SVG.
///
/// TODO: Use `postcss` to generate styles on the client side via function.
///
/// * https://stackoverflow.com/questions/75787942/given-html-string-generate-the-tailwindcss-programatically
/// * https://tailwindcss.com/docs/content-configuration#configuring-raw-content
/// * https://tailwindcss.com/docs/content-configuration#safelisting-classes
///
/// ```js
/// import postcss from "postcss";
/// import tailwindcss from "tailwindcss"
/// import autoprefixer from "autoprefixer"
/// import cssnano from "cssnano"
///
/// async function generateTailwindCss(html) {
///   return (await postcss([tailwindcss({
///     content: [{ raw:html }],
///     theme: {
///       extend: {},
///     },
///     plugins: [],
///   }), autoprefixer, cssnano])
///   .process(`
///     @tailwind base;
///     @tailwind components;
///     @tailwind utilities;
///   `)).css
/// }
///
/// const css = generateTailwindCss('<div class="m-4">HTML content</div>')
/// ```
#[cfg(not(feature = "server_side_graphviz"))]
#[component]
pub fn DotSvg(
    info_graph: Signal<InfoGraph>,
    dot_src_and_styles: Signal<Option<DotSrcAndStyles>>,
    #[prop(default = Signal::from(false))] diagram_only: Signal<bool>,
) -> impl IntoView {
    // DOM elements for the graph and error
    let svg_div_ref = NodeRef::<Div>::new();

    let (error_text, set_error_text) = leptos::prelude::signal(None::<String>);

    #[cfg(not(target_arch = "wasm32"))]
    {
        let _info_graph = info_graph;
        let _dot_src_and_styles = dot_src_and_styles;
        let _set_error_text = set_error_text;
    }

    Effect::new(move |_| {
        #[cfg(not(target_arch = "wasm32"))]
        let _svg_div_ref = svg_div_ref;

        #[cfg(target_arch = "wasm32")]
        use leptos::prelude::Set;
        #[cfg(target_arch = "wasm32")]
        if let Some(dot_src_and_styles) = dot_src_and_styles.get() {
            if !dot_src_and_styles.dot_src.is_empty() {
                use std::borrow::Cow;

                let DotSrcAndStyles { dot_src, styles, opts, theme_warnings: _ } = dot_src_and_styles;

                let opts = &serde_wasm_bindgen::to_value(&opts).unwrap();
                let (dot_svg, error) = match graphviz_dot_svg(dot_src, opts) {
                    // TODO: need to move tag nodes before all other nodes
                    //       so that tailwind peer selectors work.
                    Ok(dot_svg) => {
                        let info_graph = info_graph.get();
                        let styles = format!("\n/* TW_PLACEHOLDER */\n{styles}");
                        let images = info_graph.images();
                        let image_defs = svg_image_defs(images);
                        let dot_svg = dot_svg_sanitize(&dot_svg, &styles, images, &image_defs);
                        let dot_svg = dot_svg_append_extra(&dot_svg, info_graph.svg_extra());

                        (Cow::Owned(dot_svg), None)},
                    Err(error) => {
                        let error = js_sys::Error::from(error)
                            .to_string()
                            .as_string()
                            .unwrap_or_else(|| String::from("<unknown>"));

                        (Cow::Borrowed(""), Some(error))
                    }
                };

                if let Some(svg_div) = svg_div_ref.get() {
                    svg_div.set_inner_html(&dot_svg);
                }

                // ⚠️ Normally we should not write to a signal in `create_effect`, as it causes
                // state to be out of sync between server and client.
                //
                // However, for a client-side only component, we don't need to keep in sync with
                // the server.
                //
                // From Greg (creator of Leptos):
                //
                // > `create_effect` is also good for "only run this in the browser" and also for
                // > "synchronize with something non-reactive" (like a JS function) so don't worry
                // > about setting a signal inside it in that context.
                // >
                // > "Don't set a signal from an effect; rather, derive a signal." is advice meant
                // > in the sense "don't reactively read a signal inside an effect, and use it to
                // > set another signal". It's not the end of the world to do so, just not the best
                // > practice and can be hard to do correctly.
                set_error_text.set(error);
            }
        }
    });

    let button_tw_classes = "
        absolute
        w-6
        h-6
        border
        rounded
        text-sm

        border-slate-400
        bg-gradient-to-b
        from-slate-200
        to-slate-300

        hover:border-slate-300
        hover:bg-gradient-to-b
        hover:from-slate-100
        hover:to-slate-200

        active:border-slate-500
        active:bg-gradient-to-b
        active:from-slate-300
        active:to-slate-400
    ";

    view! {
        <div
            class="
                relative
                group
            "
        >
            // Client side tailwind processing.
            <Script src="https://cdn.tailwindcss.com" />
            // Button
            <div
                class="
                    lg:hidden
                    lg:group-hover:block
                "
            >
                <input
                    type="button"
                    title="Copy SVG"
                    onclick=SVG_WRITE_TO_CLIPBOARD
                    class=format!("
                        {button_tw_classes}
                        -top-6
                        right-8
                    ")
                    value="📄"
                ></input>
                <input
                    type="button"
                    title={move || if diagram_only.get() { "Open playground" } else { "Diagram only" }}
                    onclick={move || {
                        if diagram_only.get() {
                            r#"
                                window.open(
                                    window.location.toString()
                                        .replace("diagram_only=true", "diagram_only=false"),
                                    "_blank"
                                );
                            "#
                        } else {
                            r#"
                                var windowLocation = window.location.toString();
                                var windowLocationNext;
                                if (windowLocation.includes("diagram_only=false")) {
                                    windowLocationNext = windowLocation
                                        .replace("diagram_only=false", "diagram_only=true");
                                } else {
                                    windowLocationNext = windowLocation
                                        .concat("&diagram_only=true");
                                }
                                window.open(windowLocationNext, "_blank");
                            "#
                        }
                    }}
                    class=format!("
                        {button_tw_classes}
                        -top-6
                        right-2
                    ")
                    value="↗️"
                ></input>
            </div>

            // SVG container
            <div
                id="svg_div"
                node_ref=svg_div_ref
                class="mt-6 overflow-auto"
            />

            // Errors
            <div
                id="error_div"
                class={
                    move || {
                        let error_text = error_text.get();
                        let error_text_empty = error_text
                            .as_deref()
                            .map(str::is_empty)
                            .unwrap_or(true);
                        if error_text_empty {
                            "hidden"
                        } else {
                            "
                            border
                            border-amber-300
                            bg-gradient-to-b from-amber-100 to-amber-200
                            rounded
                            "
                        }
                    }
                }
            >{
                move || {
                    let error_text = error_text.get();
                    error_text.as_deref()
                        .unwrap_or("")
                        .to_string()
                }
            }</div>
        </div>
    }
}
