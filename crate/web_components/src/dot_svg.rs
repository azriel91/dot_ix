use dot_ix_model::{common::DotSrcAndStyles, info_graph::InfoGraph};
use leptos::{
    component,
    html::Div,
    prelude::{
        ClassAttribute, Effect, ElementChild, Get, GlobalAttributes, GlobalOnAttributes, NodeRef,
        NodeRefAttribute, Signal,
    },
    view, IntoView,
};
use leptos_meta::Script;

#[cfg(target_arch = "wasm32")]
use dot_ix_model::common::{dot_src_and_styles::GraphvizImage, Images};

cfg_if::cfg_if! { if #[cfg(target_arch = "wasm32")] {
    use wasm_bindgen::{prelude::wasm_bindgen, JsValue};

    #[wasm_bindgen(module = "/public/js/graphviz_dot_svg.js")]
    extern "C" {
        #[wasm_bindgen(catch)]
        fn graphviz_dot_svg(dot_src: String, opts: &JsValue) -> Result<String, JsValue>;
    }
}}

const SVG_WRITE_TO_CLIPBOARD: &str = include_str!("dot_svg/svg_write_to_clipboard.js");

#[cfg(target_arch = "wasm32")]
fn dot_svg_append_extra(dot_svg: &str, svg_extra: &str) -> String {
    dot_svg.replacen("<g", &format!("{svg_extra}\n<g"), 1)
}

#[cfg(target_arch = "wasm32")]
fn svg_image_defs(images: &Images) -> String {
    images
        .iter()
        .map(|(image_id, image)| {
            let GraphvizImage {
                path,
                width,
                height,
            } = image;
            format!(
                "<image \
                id=\"{image_id}\" \
                href=\"{path}\" \
                width=\"{width}\" \
                height=\"{height}\" \
                />\n"
            )
        })
        .collect::<String>()
}

/// Removes attributes from the SVG generated by dot, so that they don't
/// override tailwind styles.
///
/// # Parameters
///
/// * `dot_svg`: The SVG generated by `dot`.
/// * `styles`: The CSS styles to include within the `<style>$styles</style>`
///   element.
#[cfg(target_arch = "wasm32")]
fn dot_svg_sanitize(dot_svg: &str, styles: &str, images: &Images, images_defs: &str) -> String {
    let dot_svg = dot_svg
        .replacen("<g", &format!("<style>{styles}</style>\n<g"), 1)
        .replace("<g ", "<g tabindex=\"0\" ")
        .replace("fill=\"#000000\"", "")
        .replace("stroke=\"#000000\"", "")
        .replace("stroke=\"black\"", "")
        .replace("&nbsp;", "&#160;");

    let dot_svg = images
        .keys()
        .fold(dot_svg, |dot_svg, image_id| {
            dot_svg.replace(
                format!("<image xlink:href=\"{image_id}\"").as_str(),
                format!("<use href=\"#{image_id}\"").as_str(),
            )
        })
        .replace("</image>", "</use>")
        // Do this last, so all the previous replacements don't re-allocate the potentially large
        // string
        .replacen("<g", &format!("<defs>{images_defs}</defs>\n<g"), 1);

    dot_svg
}

/// Renders a graphviz graph as an SVG.
///
/// TODO: Use `postcss` to generate styles on the client side via function.
///
/// * https://stackoverflow.com/questions/75787942/given-html-string-generate-the-tailwindcss-programatically
/// * https://tailwindcss.com/docs/content-configuration#configuring-raw-content
/// * https://tailwindcss.com/docs/content-configuration#safelisting-classes
///
/// ```js
/// import postcss from "postcss";
/// import tailwindcss from "tailwindcss"
/// import autoprefixer from "autoprefixer"
/// import cssnano from "cssnano"
///
/// async function generateTailwindCss(html) {
///   return (await postcss([tailwindcss({
///     content: [{ raw:html }],
///     theme: {
///       extend: {},
///     },
///     plugins: [],
///   }), autoprefixer, cssnano])
///   .process(`
///     @tailwind base;
///     @tailwind components;
///     @tailwind utilities;
///   `)).css
/// }
///
/// const css = generateTailwindCss('<div class="m-4">HTML content</div>')
/// ```
#[component]
pub fn DotSvg(
    info_graph: Signal<InfoGraph>,
    dot_src_and_styles: Signal<Option<DotSrcAndStyles>>,
    #[prop(default = Signal::from(false))] diagram_only: Signal<bool>,
) -> impl IntoView {
    // DOM elements for the graph and error
    let svg_div_ref = NodeRef::<Div>::new();

    let (error_text, set_error_text) = leptos::prelude::signal(None::<String>);

    #[cfg(not(target_arch = "wasm32"))]
    {
        let _info_graph = info_graph;
        let _dot_src_and_styles = dot_src_and_styles;
        let _set_error_text = set_error_text;
    }

    Effect::new(move |_| {
        #[cfg(not(target_arch = "wasm32"))]
        let _svg_div_ref = svg_div_ref;

        #[cfg(target_arch = "wasm32")]
        use leptos::prelude::Set;
        #[cfg(target_arch = "wasm32")]
        if let Some(dot_src_and_styles) = dot_src_and_styles.get() {
            if !dot_src_and_styles.dot_src.is_empty() {
                use std::borrow::Cow;

                let DotSrcAndStyles { dot_src, styles, opts, theme_warnings: _ } = dot_src_and_styles;

                let opts = &serde_wasm_bindgen::to_value(&opts).unwrap();
                let (dot_svg, error) = match graphviz_dot_svg(dot_src, opts) {
                    // TODO: need to move tag nodes before all other nodes
                    //       so that tailwind peer selectors work.
                    Ok(dot_svg) => {
                        let info_graph = info_graph.get();
                        let styles = format!("\n/* TW_PLACEHOLDER */\n{styles}");
                        let images = info_graph.images();
                        let image_defs = svg_image_defs(images);
                        let dot_svg = dot_svg_sanitize(&dot_svg, &styles, images, &image_defs);
                        let dot_svg = dot_svg_append_extra(&dot_svg, info_graph.svg_extra());

                        (Cow::Owned(dot_svg), None)},
                    Err(error) => {
                        let error = js_sys::Error::from(error)
                            .to_string()
                            .as_string()
                            .unwrap_or_else(|| String::from("<unknown>"));

                        (Cow::Borrowed(""), Some(error))
                    }
                };

                if let Some(svg_div) = svg_div_ref.get() {
                    svg_div.set_inner_html(&dot_svg);
                }

                // ⚠️ Normally we should not write to a signal in `create_effect`, as it causes
                // state to be out of sync between server and client.
                //
                // However, for a client-side only component, we don't need to keep in sync with
                // the server.
                //
                // From Greg (creator of Leptos):
                //
                // > `create_effect` is also good for "only run this in the browser" and also for
                // > "synchronize with something non-reactive" (like a JS function) so don't worry
                // > about setting a signal inside it in that context.
                // >
                // > "Don't set a signal from an effect; rather, derive a signal." is advice meant
                // > in the sense "don't reactively read a signal inside an effect, and use it to
                // > set another signal". It's not the end of the world to do so, just not the best
                // > practice and can be hard to do correctly.
                set_error_text.set(error);
            }
        }
    });

    let button_tw_classes = "
        absolute
        w-6
        h-6
        border
        rounded
        text-sm

        border-slate-400
        bg-gradient-to-b
        from-slate-200
        to-slate-300

        hover:border-slate-300
        hover:bg-gradient-to-b
        hover:from-slate-100
        hover:to-slate-200

        active:border-slate-500
        active:bg-gradient-to-b
        active:from-slate-300
        active:to-slate-400
    ";

    view! {
        <div
            class="
                relative
                group
            "
        >
            // Client side tailwind processing.
            <Script src="https://cdn.tailwindcss.com" />
            // Button
            <div
                class="
                    lg:hidden
                    lg:group-hover:block
                "
            >
                <input
                    type="button"
                    title="Copy SVG"
                    onclick=SVG_WRITE_TO_CLIPBOARD
                    class=format!("
                        {button_tw_classes}
                        -top-6
                        right-8
                    ")
                    value="📄"
                ></input>
                <input
                    type="button"
                    title={move || if diagram_only.get() { "Open playground" } else { "Diagram only" }}
                    onclick={move || {
                        if diagram_only.get() {
                            r#"
                                window.open(
                                    window.location.toString()
                                        .replace("diagram_only=true", "diagram_only=false"),
                                    "_blank"
                                );
                            "#
                        } else {
                            r#"
                                var windowLocation = window.location.toString();
                                var windowLocationNext;
                                if (windowLocation.includes("diagram_only=false")) {
                                    windowLocationNext = windowLocation
                                        .replace("diagram_only=false", "diagram_only=true");
                                } else {
                                    windowLocationNext = windowLocation
                                        .concat("&diagram_only=true");
                                }
                                window.open(windowLocationNext, "_blank");
                            "#
                        }
                    }}
                    class=format!("
                        {button_tw_classes}
                        -top-6
                        right-2
                    ")
                    value="↗️"
                ></input>
            </div>

            // SVG container
            <div
                id="svg_div"
                node_ref=svg_div_ref
                class="mt-6 overflow-auto"
            />

            // Errors
            <div
                id="error_div"
                class={
                    move || {
                        let error_text = error_text.get();
                        let error_text_empty = error_text
                            .as_deref()
                            .map(str::is_empty)
                            .unwrap_or(true);
                        if error_text_empty {
                            "hidden"
                        } else {
                            "
                            border
                            border-amber-300
                            bg-gradient-to-b from-amber-100 to-amber-200
                            rounded
                            "
                        }
                    }
                }
            >{
                move || {
                    let error_text = error_text.get();
                    error_text.as_deref()
                        .unwrap_or("")
                        .to_string()
                }
            }</div>
        </div>
    }
}
